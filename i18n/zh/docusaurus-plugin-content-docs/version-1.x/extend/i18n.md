# 国际化

Flarum features a powerful translation system (based on [Symfony's translator](https://symfony.com/doc/5.2/translation.html) and [ICU MessageFormat](https://symfony.com/doc/5.2/translation/message_format.html)) that allows the interface to display information in virtually any language. 当你开发扩展时，你应该考虑利用Flarum的翻译， 即使你不打算用一种以上的语言使用它。

For one thing, this system will allow you to change the information displayed by your extension without editing the actual code. It will also give you the tools needed to efficiently deal with phenomena such as pluralization and agreement for gender. And you never know: it may come in handy later if you decide you want to add more languages and make your extension available to users around the world! 它还将为你们提供有效处理诸如多元化和同意性别等现象所需的工具。 而且谁也说不准：倘若你日后打算添加更多语言版本，让你的扩展插件面向全球用户开放，这些工作届时就会派上大用场！

This guide will show you how to [create a locale file](#locale-file) containing language resources for your extension, and how to [use the translator](#using-the-translator) to access those resources from within your code. You will learn how to deal with more complex translations involving [variables](#including-variables) and [HTML tags](#adding-html-tags), as well as [pluralization](#handling-pluralization) and [gender](#gender).

We will also describe the [standard format](#appendix-a:-standard-key-format) to be followed when developing language resources for Flarum, and offer [some tips](#appendix-b:-coding-for-the-world) that can help you make your language resources easier to localize. 但首先让我们首先概述当显示第三方扩展的输出时，Flarum如何优先排列资源。

## Flarum 如何翻译

In your code, instead of hardcoding strings in a language, you will call the `trans` method on a translator object, providing a unique translation key and optionally some variables.
然后，当用户访问页面时，Flarum会在其注册的翻译文件中看到匹配的翻译。

Flarum 从几个来源拉取翻译：

- 扩展源代码中包含的本地化文件。
- [Language packs](language-packs.md), which include translations for multiple extensions.

As a rule, a Flarum site can only display translations corresponding to the language packs that have been installed on that site. But Flarum will do its level best &mdash; within this limitation &mdash; to render your extension's output in some sort of user-readable language: 但受限于此，Flarum 仍会尽最大努力，将你的扩展插件输出内容转换为用户可读的形式：

1. 它将首先寻找用户首选显示语言的翻译。
2. 如果找不到一个，它将寻找论坛默认语言的翻译。
3. 作为最后的一种努力，它将寻找产出的“通用”英文译文。
4. 如果没有上述内容，它将放弃并显示翻译键。

因为英文翻译可能是论坛用户和看不见的翻译密钥之间唯一的事情， 我们强烈建议列入一整套英文资源，并作一切扩充。 (如果你想要在Flarum Marketplace上列出你的扩展，启动时你还需要包含英语资源。)。 Generally, extension developers will include English translations in their extension, and other language translations in a [language pack](language-packs.md).

## 本地文件

Flarum's language resources use the [YAML](https://en.wikipedia.org/wiki/YAML) file format. The locale files for a third-party extension need to be stored in the extension's `locale` folder. Each locale file should be named using the [ISO 639-1 code](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) for the language it contains. For example, a file containing French translations should be named  "`fr.yml`".

:::tip

If you wish to provide support for a specific locale, you can add an underscore followed by an [ISO 3166-1 alpha-2](https://en.wikipedia.org/wiki/ISO_3166-1#Current_codes) country code; the filename for French as spoken in Canada, for example, would be "`fr_CA.yml`". 但您必须包含一个包含同一语言的“通用”翻译的区域文件。 如果用户指定了您没有规定的区域设置，Flarum将会有它可以返回的东西。

:::

The extension skeleton includes a `locale/en.yml` template where you can put your extension's English translations. 如果您想要为另一种语言或本地添加资源，只需复制模板并给它一个适当的文件名。 然后打开文件并开始添加您的翻译！

### 添加键

Each translation in the locale file must be preceded by a key, which you will use as the **identifier** for that translation. The ID key should be in `snake_case` and followed by a colon and a space, as shown below:

```yaml
sample_key: This is a sample translation.
```

You can also use keys to **namespace** your translations. 首先，本地化文件的首行需包含一个独立的键名，用于将扩展插件的所有翻译内容归集至同一个命名空间中。 For starters, the first line of the locale file should consist of a single key that collects all the translations for your extension in a single namespace.

Additional keys can be used to divide the extension namespace into groups. This comes in handy when you want to organize your translations according to where they appear in the user interface, for example. These intermediate namespacing keys should always be in <code>snake_case</code>. 当您想要按照用户界面中出现的地方来组织翻译时，这很简单。 These intermediate namespacing keys should always be in `snake_case`.

每个命名空间键也应跟随冒号。 Each namespacing key should also be followed by a colon. Keys should be nested according to the YAML outline format, adding two spaces of indentation for each level in the hierarchy. Put this all together, and the locale file for the <a href="start.md">Quick Start tutorial</a> might look something like this: Put this all together, and the locale file for the [Quick Start tutorial](start.md) might look something like this:

```yaml
acme-hello-world:                # Namespacing for the extension; unindented.
  alert:                         # Namespacing for alerts; indented 2 spaces.
    hello_text: "Hello, world!"  # Identifier/translation; indented 4 spaces.
```

Once you have this information in place, you can form the **full translation key** that you will use to access a translation by listing its keys in order from extension namespace to an identifier, with periods as delimiters. For example, the full translation key for the "Hello, world!" translation would be:

```javascript
'acme-hello-world.alert.hello_text'
```

That's really all you need to know about the mechanics of key creation. Please be aware, however, that there is a standard format that developers need to follow when creating language resources for Flarum. The rules for [namespacing translations](#namespacing-translations) and [naming ID keys](#naming-id-keys) may be found in Appendix A.

### Adding Translations

The examples in the preceding section have already given you the basics: you type an ID key &mdash; followed by a colon and a space &mdash; then you type in the translation. It's that easy! Here we would just like to add a few details that will help you deal with longer and more complex translations. It's that easy! Here we would just like to add a few details that will help you deal with longer and more complex translations.

:::caution Quotation Marks

You may have noticed that only one of the two sample translations in the previous section was enclosed in quotation marks. It is generally not necessary to delimit translations in this way. You should, however, use **double quotes** to enclose any translation that includes one or more of the following characters:

```
`  !  @  #  %  &  *  -  =  [  ]  {  }  |  :  ,  <  >  ?
```

Since Flarum uses curly brackets and angle brackets to denote placeholders for [variables](#including-variables) and [HTML tags](#html-tags), respectively, it goes without saying that any translation that includes such placeholders will also need to be enclosed in double quotes.

Furthermore, you should use **single quotes** to enclose any translation that includes one or more double quote (`"`) or backslash (`\`) characters. This rule takes precedence! So if a translation were to include both double quotes and one or more characters from the list above &mdash; as does [this example](#including-variables), in which a variable placeholder is set off by quotation marks &mdash; you would need to enclose it in _single quotes_.

:::

#### Literal Blocks

When you need a translation to appear as more than a single line of text, the translation should be added as a **literal block**. Enter a vertical bar (`|`) character where you would normally begin the translation, then add the translation below the ID key, indenting each line by an extra two spaces:

```yaml
literal_block_text: |
  These lines will be displayed as shown here, line breaks and all.

      Extra indentation is also preserved: this line will be indented 4 spaces!

  Quote marks are unnecessary, even when the block contains special characters.
```

The literal block ends with the last line to be indented at least two spaces more than the ID key. Quotation marks are not needed because the block is effectively delimited by this extra two spaces of indentation. Quotation marks are not needed because the block is effectively delimited by this extra two spaces of indentation.

Flarum's core language resources employ literal blocks mainly for email body content.

#### Key References

It's not uncommon to use the same bit of text in more than one location or context. It's not uncommon to use the same bit of text in more than one location or context. Let's assume that you want your extension to display the phrase "Edit Stuff" in two locations in the user interface:

- As a **button** that users can click when they want to edit some stuff
- As the **title** of a dialog box displayed when users click that button

Your instinct might be to add a single translation &mdash; let's call it "`edit_stuff`" &mdash; and use that ID key twice in your code. This approach is efficient, but it lacks flexibility: in some languages, it may not be possible to use the same phrase for both the button and the dialog title! This approach is efficient, but it lacks flexibility: in some languages, it may not be possible to use the same phrase for both the button and the dialog title!

```yaml
edit_stuff_button: => edit_stuff    # Used in the code that creates the button.
edit_stuff_title: => edit_stuff     # Used in the code that creates the dialog.

edit_stuff: Edit Stuff              # Not used in the code.
```

You can set one key to reference another by replacing its translation with an equal sign (`=`), a greater-than sign (`>`), and a space, followed by the full translation key to be referenced. When the extension is installed, Flarum's compiler will resolve these references to create a complete set of translations it can use.

There's more to be said about referencing &mdash; for one thing, we've totally ignored the issue of namespacing in the above example! And you may be wondering why we suggested creating three keys when two would suffice. For an explanation, see the rules for <a href="#reusing-translations">reusing translations</a> in Appendix A. And you may be wondering why we suggested creating three keys when two would suffice. For an explanation, see the rules for [reusing translations](#reusing-translations) in Appendix A.

## Using the Translator

Once you've added a translation to your locale file, with appropriate namespacing and identifier keys, you can use the `app.translator.trans()` method to reference that translation in your code. For instance, the `js/forum/src/index.js` file for the [Quick Start tutorial](start.md) might end up looking like this:

```javascript
app.initializers.add('acme-hello-world', function() {
  alert(app.translator.trans('acme-hello-world.alert.hello_text'));
});
```

This shows the basic translation method, with no bells or whistles attached. Below you'll find examples of more complex translations involving things like [variables](#including-variables) and [HTML tags](#html-tags). (Please note that we've omitted the namespacing in the following examples to keep them simple; if you look at the actual code, you'll find the translations are properly namespaced according to the [standard format](#namespacing-translations).)

## Including Variables

You can include variables in translations. As an example, let's look at the code that creates the first item in Flarum's [search results dropdown](https://github.com/flarum/framework/blob/main/framework/core/js/src/forum/components/DiscussionsSearchSource.tsx). This button quotes the search query entered by the user &mdash; information that is passed to the translator along with the translation key, as an additional parameter:

```jsx harmony
{LinkButton.component({
  icon: 'search',
  children: app.translator.trans('all_discussions_button', {query}),
  href: app.route('index', {q: query})
})}
```

A matching placeholder in the translation lets the translator know where it should insert the variable:

```yaml
all_discussions_button: 'Search all discussions for "{query}"'
```

Since curly brackets are used to denote the placeholder, the translation as a whole needs to be enclosed in [quotation marks](#quotation-marks). Normally, double quotes would be used; but since this particular translation is using double quotes to set off the search query, the single-quote rule takes precedence.

### Adding HTML Tags

Abstracting translations from HTML can pose a unique challenge: How do you deal with HTML elements that affect just part of the sentence? Fortunately, Flarum gives you a way to add tags to your translations. Fortunately, Flarum gives you a way to add tags to your translations.

You begin by adding a key to the parameters argument for each element that you want the translator to handle. The following snippet — from the [Edit Group modal](https://github.com/flarum/framework/blob/main/framework/core/js/src/admin/components/EditGroupModal.js) of the admin interface — shows a translation key accompanied by a parameters object with one item.

```jsx harmony
<div className="helpText">
  {app.translator.trans('icon_text', {
    a: <a href="https://fortawesome.github.io/Font-Awesome/icons/" tabindex="-1"/>
  })}
</div>
```

请注意，每个参数都使用单个的 HTML 标记定义，并在关闭角度括号前添加斜线。 Note that each parameter is defined using a single HTML tag, with a slash added before the closing angle bracket. You can then use HTML-style opening and closing tags in your locale file to specify which part of the translation is affected by each element. Once again, double quotes are required. You can see that not all tags are passed as an argument, only those who have attributes. 再次需要双引号。
您可以看到并非所有标签都作为参数传递，只有那些具有属性的标签。

```yaml
icon_text: "Enter the name of any <a>FontAwesome</a> icon class, <em>without</em> the <code>fa-</code> prefix."
```

Of course, you can give a parameter any name you like &mdash; you could use `<fred>` and `</fred>` to enclose your link text if you really wanted to! 但我们建议尽可能靠近实际的 HTML 标签， 这样你的本地化人将能够理解正在发生的事情。

本地化器可以根据需要重新排序元素，甚至选择省略标签。 Localizers can reorder elements as needed, and even choose to omit tags if they so desire. But they can't add any tags of their own: the translator will simply ignore any HTML-style tag that doesn't correspond to a properly defined parameter in the code.

### 多元化和 ICU 消息格式

有时候您可能需要提供翻译的替代版本以适应单词或短语的复数。 On occasion, you may need to provide alternate versions of a translation to accommodate pluralization of a word or phrase. 最经常使用的是多元化和性别化。

```js
const remaining = this.minPrimary - primaryCount;
return app.translator.trans(
  'choose_primary_placeholder',
  { count: remaining }
);
```

This example is from the [Choose Tags modal](https://github.com/flarum/tags/blob/master/js/src/forum/components/TagDiscussionModal.js) of the Tags extension, where it tells the user how many more primary tags can be selected. 以下是ICU MessageFormat 中上述代码的英文译文：

```yaml
choose_primary_placeholder: "{count, plural, other {Choose {count} primary tags}}"
```

In this case, we call the pluralization variable `count`. This isn't required, but we strongly recommend using `count` for consistency.

Of course English has only two variants: singular or plural. You may want to provide additional variants when creating translations for a language that has more than one plural form. 您可能想要在创建一个多于一个复数形式的语言的翻译时提供额外的变体。

In addition to `=0/=1/=2/...` and `other`, the following plural keywords are supported: `zero`, `one`, `two`, `few`, and `many`.

See the [Symfony Translation docs](https://symfony.com/doc/5.2/translation/message_format.html) for more complex examples.

### 处理性别问题

Support for grammatical gender will be added in a future version of Flarum. Detailed instructions will be provided here once that functionality becomes available. 一旦功能完备，将在此提供详细说明。

## 服务器端翻译

Translation is generally handled by Flarum's front-end client. However, you can use translations in your PHP code if you need to. 但是，如果您需要，您可以在PHP代码中使用翻译。

First, you'll need to get an instance of the `Flarum\Locale\Translator` class. You'll usually do this by typehinting this class in the constructor of your class so a translator instance is injected by the [IoC Container](https://laravel.com/docs/8.x/container). If dependency injection is not available, you can use `resolve(Translator::class)`. Don't forget a `use Flarum\Locale\Translator;` statement at the top of your PHP file!

然后，API类似于 JavaScript 翻译类。 You can use `$translator->trans` like you'd use `app.translator.trans` in JavaScript.
You can learn more about the Translator's methods in [Symfony's `Translator` documentation](https://symfony.com/doc/5.2/translation/message_format.html), which Flarum's `Translator` extends.

## 注册本地化语言包

There's one last thing you need to do before Flarum can use your translations. You need to register them. Fortunately, Flarum makes this pretty easy. Add the following to your <code>extend.php</code>: 您需要注册它们。 幸运的是，Flarum很容易做到。 Add the following to your `extend.php`:

```php
new Extend\Locales(__DIR__ . '/locale'),
```

## 附录A：标准键格式

为用于Flarum核心和捆绑扩展而制定了下列准则。 The following guidelines were created for use in the Flarum core and bundled extensions. Their purpose is to ensure that translation keys are organized and named in a consistent fashion, so Flarum's localizers will be able to create and maintain high-quality language packs with a minimum of difficulty.

希望为Flarum开发做出贡献的开发者将遵循这些准则。 Developers who wish to contribute to the development of Flarum are expected to follow these guidelines. Third-party developers may also wish to follow them, so experienced Flarum localizers who undertake the translation of third-party extensions will find themselves working in familiar surroundings.

### 命名空间翻译

All translations are to be organized in categories, using namespacing keys arranged in up to **three** levels. Each level provides localizers with an important bit of information about _where the translation is used:_

#### ➡ The top-level key indicates _which component uses the translation_.

The namespacing for translation keys used in official Flarum components, including bundled extensions, should match the name of the language pack locale file for the component in question. The namespaces for Flarum's non-extension components are fixed as shown below: Flarum非扩展组件的命名空间如下所示：

```yaml
core:        # Translations used by the Flarum core
validation:  # Translations used by Laravel's validator
```

Translation keys used in an extension &mdash; including any third-party extension &mdash; need to be namespaced using the extension's name in `vendor-package` format where the `flarum-` and `flarum-ext-` prefixes are stripped from the `package` (e.g, `flarum-tags` for the Tags extension and `foo-bar` for a `foo/flarum-ext-bar` extension).

There should be only **one** first-level prefix in any locale file; it should be the first line in the locale file.

#### ➡ The second-level key indicates _which interface uses the translation_.

Since Flarum doesn't have all that many interfaces, we've come up with a short list of second-level keys for you to choose from. We've included the more frequently used ones in the locale file template created with the extension skeleton. Below you will find the complete list, with explanations: 我们已经在扩展组件创建的本地化文件模板中包含了常用的内容。 下面你会找到完整的列表，并且有解释：

```yaml
admin:       # Translations used by the admin interface.
forum:       # Translations used by the forum user interface.
lib:         # Translations used by either of the above.
views:       # Translations used outside the normal JS client.
api:         # Translations used in messages output by the API.
email:       # Translations used in emails sent by Flarum.
```

前四个键大致对应包含该名称空间中的翻译代码的目录。 (Most of your keys will probably go in `admin` or `forum`.) The remaining two keys are a bit different: the `api` namespace is for translations used in messages output by the API, while the `email` namespace contains the resources for all emails sent by the forum.

```yaml
ref:         # Translations referenced by more than one key.
group:       # Translations used as default group names.
```

These two keys don't correspond to interfaces; they're for translations that require special handling. We'll explain how to use the <code>ref</code> namespace when we talk about <a href="#reusing-translations">reusing translations</a>. The <code>group</code> namespace holds the default group names, which are translated by the server rather than at the front end. We'll explain how to use the `ref` namespace when we talk about [reusing translations](#reusing-translations). The `group` namespace holds the default group names, which are translated by the server rather than at the front end.

#### ➡ The third-level key indicates _which part of the UI uses the translation_.

The keys in this level are not so rigidly defined. Their main purpose is to chop the UI up into manageable chunks, so localizers can find the translations and see for themselves how they are used by the software. (Third-level keys aren't used in the `ref` and `group` namespaces, which don't need chopping.)

If you're modifying an existing location &mdash; to add a new setting to the Settings page, for example &mdash; you should copy our namespacing so experienced Flarum localizers will know at a glance exactly where the new translations are displayed. See English translations in <code>flarum/core</code> and bundled extensions for examples. See English translations in `flarum/core` and bundled extensions for examples.

If your extension adds a new location &mdash; such as a new dialog box &mdash; you should feel free to create a new third-level key to namespace the translations that go there. Take a couple minutes to familiarize yourself with the namespacing in the locale files linked above, then create a new key that fits in with that scheme. Take a couple minutes to familiarize yourself with the namespacing in the locale files linked above, then create a new key that fits in with that scheme.

As a general rule, third-level keys should be short &mdash; no more than one or two words &mdash; and expressed in `snake_case`. They should be descriptive of the locations where the translations are used.

### Naming Identifier Keys

Like the third-level namespacing keys, identifier keys should be expressed in `snake_case`. ID keys should be arranged in alphabetical order within each namespace, so they'll be easy for developers to find. (There is one exception to this rule! ID keys in the `email` namespace should be listed just as they appear in your mail client: `subject` first, then `body`.)

The typical ID key consists of two parts &mdash; a **root** and a **suffix** &mdash; each of which may be omitted in certain circumstances. Just as the namespacing keys tell localizers _where the translation is used_, each part of the ID key provides a further bit of information about the translation:

#### ➡ The suffix indicates _how the translation is used_.

We'll start with the suffix because it's the most important part of the key name. It tells localizers what sort of object they should look for when trying to find the translation in the interface. For example, the suffixes in the following list are used for GUI objects more or less related to user operations:

```yaml
_button:        # Used for buttons (including dropdown menu items).
_link:          # Used for links that are not shown graphically as buttons.
_heading:       # Used for headings in tables and lists.
_label:         # Used for the names of data fields, checkbox settings, etc.
_placeholder:   # Used for placeholder text displayed in fields.
```

These suffixes are used for informative or descriptive text elements:

```yaml
_confirmation:  # Used for messages displayed to confirm an operation.
_message:       # Used for messages that show the result of an operation.
_text:          # Used for any text that is not a message, title, or tooltip.
_title:         # Used for text displayed as the title of a page or modal.
_tooltip:       # Used for text displayed when the user hovers over something.
```

And there are two suffixes that are used only in the `email` namespace:

```yaml
_body:          # Used for the content of the email message.
_subject:       # Used for the subject line of the email message.
```

The above is a complete listing of the suffixes available for use in locale files. You should take care to use them consistently, as doing so will make life easier for localizers. The above is a complete listing of the suffixes available for use in locale files. You should take care to use them consistently, as doing so will make life easier for localizers. If you feel something is missing from the list, please file an issue with the developers; we'll consider adding a new suffix if the situation warrants it.

Suffixes should be **omitted** from ID keys for [reused translations](#reusing-translations) in the `ref:` namespace. This is because you can't be sure these translations will always be used in the same context. This is because you can't be sure these translations will always be used in the same context.

#### ➡ The root indicates _what the translation says_.

In other words, it should be a brief summation of the translation's content. In other words, it should be a brief summation of the translation's content. If it's very long, on the other hand, you should try to boil it down to as few words as possible.

In some cases, the summary may be replaced by a description of the object's function. This is commonly seen in buttons. The button that submits a form should be identified as a `submit_button` regardless of whether the translation says "OK" or "Save Changes". In a similar vein, the button that dismisses a dialog or message box is always a `dismiss_button`, even if it actually reads "OK" or "Cancel".

The root may also be **omitted** in certain cases &mdash; usually when the suffix alone is sufficient to identify the translation. The root may also be <strong x-id="1">omitted</strong> in certain cases &mdash; usually when the suffix alone is sufficient to identify the translation. For example, it's unlikely that a page or dialog box will have more than one title &hellip; and like as not, the content of the title is already given in the third-level namespacing! So the suffix can stand alone. So the suffix can stand alone.

Suffixes are also sufficient to identify the subject and body components of an email message since each email will have only one subject line and one body. Note that the leading underscore is omitted in such cases: you would use just <code>title</code>, <code>subject</code>, or <code>body</code> as the ID key. Note that the leading underscore is omitted in such cases: you would use just `title`, `subject`, or `body` as the ID key.

### Reusing Translations

Flarum's unique [key references](#key-references) fulfill the same role as YAML anchors, but they're better in one respect: you can even reference keys in a different file! For this reason, you need to use the **full translation key** when referencing. Here's a more realistic example of how referencing works, complete with namespacing:

```yaml
core:

  forum:
    header:
      log_in_link: => core.ref.log_in

    log_in:
      submit_button: => core.ref.log_in
      title: => core.ref.log_in

  ref:
    log_in: Log In
```

As you can see, we want to reuse a single translation in three different contexts (including two locations): (1) as a link displayed in the site header, (2) as a button displayed in the Log In modal, and (3) as the title of that modal. So all three of these keys have been set to reference the same full translation key. So all three of these keys have been set to reference the same full translation key.

The reused translation is identified by a key that omits the suffix &mdash; as specified [above](#naming-identifier-keys) &mdash; and is placed in the `ref` namespace. The latter measure is needed to avoid conflicts that can occur if a reused translation is given the same name as a second-level namespacing key. (The `email` keys are a case in point.)

The `ref` namespace also makes it easy to track translation reuse. Imagine what would happen if you set the scalars for the button and title to reference `core.forum.header.log_in_link` instead:

```yaml
core:

  forum:
    header:
      log_in_link: => Log In

    log_in:
      submit_button: => core.forum.header.log_in_link  # Never reference keys
      title: => core.forum.header.log_in_link          # that aren't in "ref"!
```

It would very easy to change the translation for the header link without realizing that you're also changing things in the Log In modal &mdash; to say nothing of any extensions that might also be referencing that key! This sort of thing will be less likely to occur if you keep your reused translations in the <code>ref</code> namespace. Third-party extensions are welcome to reference keys in the `core.ref` namespace, but please be aware that we cannot add translations to this namespace based on reuse in third-party extensions.

For this reason, any key references in the [core resources](https://github.com/flarum/framework/blob/main/framework/core/locale/core.yml) **must** point to keys in the `core.ref` namespace. 内置扩展的资源文件中，翻译键名的引用可指向以下两个位置之一：

- Extension-specific translations should go in the `ref` namespace of the extension's locale file.

- Translations used by both the extension and the core should go in the `core.ref` namespace.

Third-party extensions are welcome to reference keys in the `core.ref` namespace, but please be aware that we cannot add translations to this namespace based on reuse in third-party extensions. A third-party dev who wants to reuse a translation from a namespace other than `core.ref` will need to add a properly keyed duplicate translation to the extension's locale file.

任何扩展都不应引用另一个扩展的键，因为这样做会导致依赖性。

One final caution: translation keys in the `ref` namespace should **never** be inserted directly in code. 这是因为本地化器可能最终创建一个翻译来替换每个引用的翻译键 &mdash; ，在这种情况下，他们将在其权限范围内从本地化文件中移除该键。 倘若代码中使用了此类键名，最终将会因缺少对应的匹配资源，而无法完成该键名的译文渲染！

### 添加注释

评论 (和空行) 应添加到本地化文件中，以便本地化器能够更容易地导航。

We've included some **block comments** in the locale file template included with the extension skeleton. 它们是为了提醒开发者注意一些基本概念：翻译键名不得在多个位置重复使用；复用译文对应的键名，绝不能直接写入代码中；诸如此类。

You should add **comment lines** above every second- or third-level namespacing key, to give localizers a more complete description of the location covered by that namespace. 复制现有键时，肯定也要复制评论(并在必要时修改)。 如果您添加了一个新的第三方的键，请记得在前面加上一个注释来解释添加的位置。

You may also wish to add **inline comments** after a specific translation to provide localizers with further information about that translation (such as the fact that a translation can be pluralized if necessary).

## 附录 B：面向全球的编码开发

在本附录中， 我们想要提供一些可能有助于您避免在国际化过程中出现某些常见陷阱的小技巧。 In this appendix, we'd like to offer a few tips that may help you to avoid some of the more common pitfalls in the internationalization process. Abstracting language from code is easily one of the more humdrum tasks a programmer has to deal with, but if you don't give due attention to the subtleties involved, you're likely to end up creating your localizers an unnecessary headache or two.

当然，这不仅仅是为了让本地化更容易。 毕竟日后有人因此遇到问题时，都会来找你求助 —— 而彼时，你往往早已搁置这个项目、转而投入其他开发工作，时间过去数月，甚至数年之久！ 在开发工作中，这样的场景再常见不过：事前花些许功夫做好预防，日后解决问题时，往往能省去数倍的精力—— 而这一点，对所有相关人员而言皆是如此。

It's probably impossible to avoid localization issues completely; there are just too many variables. But by following a few simple guidelines, you should be able to head off many issues before they happen. 但是，通过遵循几个简单的指导方针，你应该能够在问题发生之前就提出许多问题。

### 消除所有硬编码文本！

这也许是不言而喻的。 This probably goes without saying. After all, if you're going to go to the trouble of extracting translations, you might as well finish the job, right? Well, yes, but that's easier said than done. It's really quite unusual to find a program that doesn't have at least a few bits of hardcoded text floating around somewhere. 好的，但说起来比做起来容易。 找到一个没有至少几位硬码文本浮动到某处的程序确实很不寻常。

甚至很小的文本区块也会给本地化者造成问题。 Even tiny bits of text can cause problems for localizers. A comma here, a colon there &hellip; perhaps a pair of brackets inserted to make the page more legible: such things can and do cause issues for localizers. After all, not all languages use the same glyphs for these things! Just one hardcoded space can be a problem for someone trying to translate the interface into a language that doesn't use spaces to separate words. 毕竟，并非所有语言在这些内容的表达上，都会使用相同的字符符号！ 对于试图将接口翻译成不使用空格分隔单词的语言的人来说，只有一个硬码空间可能是一个问题。

Generally speaking, any displayed text that isn't supplied by a variable or the result of a calculation _must_ be included in the locale files. 说得很容易，但实际上这样做需要坚持不懈。

### 避免硬编码语法！

Hardcoded text isn't the only way that code can create problems for localizers. Hardcoded syntax issues occur when the code forces words into a specific order that just won't work in other languages. They are generally the result of using two translations where just one would be more appropriate. 硬编码语法问题发生在代码将单词强制为特定的顺序，而不会在其他语言中工作。 它们通常是使用两种译文的结果，其中只有一种更为合适。

For an example, let's look at the line of text that's printed near the bottom of the [Log In modal](https://github.com/flarum/framework/blob/main/framework/core/js/src/forum/components/LogInModal.tsx):

> Don't have an account? [Sign Up](#)

我们原先将此行编码为两种翻译，这两种翻译被一个硬码空间分隔：

```yaml
before_sign_up_link: "Don't have an account?"
sign_up: Sign Up
```

这样做有很好的理由。 一来，这让将文本后半部分设为超链接的操作变得十分简便。 There were good reasons for doing it this way. For one thing, it made it easy to turn the second half into a link. And since the second translation is reused elsewhere, keeping it separate seemed like a no-brainer.

但这种做法存在问题。 如上文所述，硬编码空间似乎可能对某些本地化人员造成问题。 But there were problems with this approach. The hardcoded space seemed likely to pose issues for some localizers, as mentioned above. And splitting this text into two strings would make it impossible to render the line as a single sentence with the link embedded in the middle:

> If you don't have an account yet, you can [sign up](#) instead!

既然本地化者似乎可能需要这种灵活性， 我们选择将该行抽象为单个翻译，使用 HTML样式标签来关闭链接文本：

```yaml
sign_up_text: "Don't have an account? <a>Sign Up</a>"
```

This puts the (formerly hardcoded) space in the translation, so localizers who don't need it can remove it. And the tags can be positioned freely within the translation, making this approach much more flexible. 标签可以自由放置在翻译中，使这种方法变得更加灵活。

The moral of this story is: when you've got two adjacent chunks of text which seem related to each other grammatically &mdash; or even semantically &mdash; you should think about finding a way to incorporate them both in a single translation. Your localizers may have cause to thank you! 您的本地化器有理由感谢您！

We might also conclude that the presence of little bits of hardcoded text &mdash; such as the hardcoded space in this example &mdash; may be a sort of [code smell](https://en.wikipedia.org/wiki/Code_smell) indicating the presence of a deeper issue. 情况并非总是如此，但这是一个值得考虑的可能性。

### 留意复数形式！

令人吃惊的是，它们很容易被忽视。 They are surprisingly easy to overlook. Of course, the need for pluralization support is fairly obvious here:

> Toby likes this.
> You like this.
> Toby likes this. You like this. Toby and Franz like this.

And the situation is complicated by the presence of the second-person pronoun, since it always takes the plural form in English, even when we're talking about one person. That's why the `app.translator` call is so complicated in the code that outputs the above sentences for the [Likes extension](https://github.com/flarum/likes/blob/master/js/src/forum/addLikesList.js).

Now look at this similar set of sentences, output by similar code in the [Mentions extension](https://github.com/flarum/mentions/blob/master/js/src/forum/addMentionedByList.js):

> Toby replied to this.
> You replied to this.
> Toby replied to this. You replied to this. Toby and Franz replied to this.

In English, the simple past tense is not affected by pluralization. In English, the simple past tense is not affected by pluralization. Of course, that simply wouldn't work for the French localizer, who needs to inflect the verb differently in each of the above three sentences.

This is the sort of situation where the humdrum chore of language abstraction requires a bit of extra care and attention. Remember to ask yourself whether each noun (or pronoun) can be pluralized. If it can, make sure to pass an appropriate variable to the translator. Of course, you don't need to provide any variant translations in the English resources &hellip;

```yaml
mentioned_by_text: "{users} replied to this."       # Can be pluralized ...
mentioned_by_self_text: "{users} replied to this."  # Can be pluralized ...
```

&hellip; but it would be a very good idea to add a comment after the translations in question, to alert localizers to the fact that the code will support the addition of such variants, should they be necessary.

### Reuse Translations, Not Keys!

If the namespacing keys combine to form a complete specification of where a translation is used, and the ID key specifies exactly how the translation is used and what it says, then it stands to reason that every full translation key must be unique. In other words: <em x-id="3">you should never use the same key more than once!</em> In other words: _you should never use the same key more than once!_

Although this may sound inefficient, there's a good reason for doing things this way: it's the easiest way to ensure that localizers will have the flexibility they need. If you reuse keys in your code, you'll eventually hit a snag. Although this may sound inefficient, there's a good reason for doing things this way: it's the easiest way to ensure that localizers will have the flexibility they need. If you reuse keys in your code, you'll eventually hit a snag. Your localizers will be unable to find a single expression that fits every context where you've used some key or other &hellip; and then they'll start bugging you to fix your code.

Fortunately, you can avoid many such issues if you simply take care to [namespace translations](#namespacing-translations) correctly, [name your ID keys](#naming-identifier-keys) appropriately, and always [reuse translations](#reusing-translations) instead of keys. Though it may seem like a bother, in the long run, the [standard format](#appendix-a:-standard-key-format) will make localization much easier for _everyone_.
